---
title: 面试记录
description: 面试记录
---

### 珠海格力

#### 箭头函数和普通函数的区别

- 箭头函数没有自己的 this 指向，它的 this 指向上下文的，而普通函数 this 指向最后调用它的那个调用者。
- 箭头函数没有`arguments`，因为它没有`prototype`属性。
- 箭头函数更简洁，ES6 后出的。
- 箭头函数的形参当只有一个的时候，可以省略小括号，如果执行体只有一条语句可以去掉大括号，并且可以省略`return`关键字

#### 数组去重的方法

- for、while 循环
- ES6 的`new Set`方法

#### 组件通信传递方式

- 父子通信 `props`、`emit`、`ref`
- vuex、eventBus
- 跨级组件 `provide`提供者、`inject`消费者

#### vue2 的响应式原理是什么

vue2 响应式原理使用到了 ES5 的`Object.defineProperty`来对数据的劫持，进而实现数据的双向绑定。

当我们定义在 data 里面的数据，vue 底层帮我们使用到了 defineProperty 来给数据绑定`get`和`set`，但读取属性时，会触发 get 这个方法，当修改属性时，会触发 set 这个方法，对于一些深层次的结构对象，需要使用递归来遍历每个属性，所以初始化是比较损失性能的。这个方法是不能够侦听到数据的变化的，但是可以使用到 vue 给我们重写了那七个改变原数组的方法来实现修改数据响应页面，push、pop、unshift、shift、sort、reverse、splice 方法。同时给对象后添加新的属性和删除属性，是没有响应式的。可以使用 vue 给我们提供的$set 方法。

#### API 封装包含哪些方面

比如设置 baseUrl 基地址、统一的响应超时时间，请求、响应拦截器等。

- 建立 api 文件。
- 根据不同的接口类型存放不同的 js 文件里，便于后期查找和阅读。

#### 项目中做过了哪些前端优化

- 路由的懒加载，减少首屏加载时间
- 对于一些小图标，做成精灵图，减少请求次数
- 一些公共样式单独抽离出来，需要引入使用
- 对于一些长列表数据，可以使用表格进行分页，数据一页一页的往服务器里取，减少服务器压力
- api 的封装
- 封装骨架屏，减少用户在等待时间的焦虑

#### 怎么判断数据类型？ 引用类型/常用类型

- 引用类型

  - 利用万能检查类型方法`Object.prototype.toString.call(要检测的数据)`

    ```js
    const str = "杨某某";
    console.log(Object.prototype.toString.call(str)); // [object String]
    ```

- 基本类型

  - typeof
    - 判断太多数类型都是准确的，注意`typeof null ==> object`
  - instanceof
    - 判断目标数据是否在谁的`原型链`上，返回一个布尔值。

#### js 中有几种数据类型

- undefined
- null
- String
- Number
- Boolean
- Object
- bigInt `ES6后出`

#### 跨域的问题

跨域，是浏览器出于安全考虑提出同源策略。是仅仅存在于浏览器和服务器之间，协议、端口号、域名有一个不同都违反了浏览器的同源策略。

解决方法：

- jsonp：只支持 get 请求，不支持 post 请求
- 反向代理：配置一下即可解决跨域问题，底层是帮我们开启了一个微型服务器，通过这个微型服务器去访问目标服务器取数据，去到数据再返回给浏览器，因为服务器和服务器之间是不存在跨域问题的。
- ifram 标+|domain

#### 对 vue2 的理解

`响应式原理`：vue2 是使用`Object.defineProperty`来对数据劫持，实现响应式的。

缺点：

- 初始化数据给数据递归遍历绑定 get、set 是比较损耗性能的。
- 不能侦听数据的变化，需要使用到 vue 给我们重写的那七个方法和`$set`来实现数据的响应式
- 对于对象后添加的属性和删除属性是无法检测到的，所以不是响应式的，可以利用`$set`方法
- 对于 vue2，vue3 使用的`Proxy`代理对象实现数据的响应式的，这个方法实现数据的响应式比起 vue2 来说，性能来说是比较好的，因为 Proxy 是对整个对象做代理，不需要递归遍历所有数据绑定 get、set，而且能够侦听数组的变化，对于对象后添加的属性也能监听到。

#### vue2 和 vue3 的区别

- 实现响应式原理不一样
- vue3 不需要像 vue2 那样 this 拿数据
- vue3 使用了 TS 重写了，更好的类型推断，更好的支持 TS
- `重要`：vue3 也引入了`hooks`函数
- 定义数据方式不一样，vue2 是传统的`options`api，而 vue3 改为了`composition`api，传统的 options 更好的学习成本，利于初学者学习，但不利用后期维护，composition 更好复用代码以及后期维护
- vue3 最大的特点，我觉得是引入了 hooks，更好的代码复用，也解决了 vue2 的代码复用 mixins 的缺点：`数据来源不够明确`，`命名冲突`等问题。hooks 的出现正好解决了这个问题。
- 生命周期不一样：vue3 移除了`beforeCreate`和`created`钩子，可使用`setup`方法代替 vue2 的 beforeDestroy===>beforeUnMount 、 destroyed ---- unMounted

#### 项目中平时怎么管理接口

- 利用 apipost 管理

#### 项目中对于重复请求是如何解决的

利用`repeat-request-minde`这个库检测有没有重复请求接口。

重复请求的危害：

- 增加服务器的压力
- 可能会因为其中的某个请求失败导致页面显示错误

解决思路：

- 前置处理：一般开发的时候可能不会留意到有重复的请求，要避免这种情况需要自动监控并给出警告，才能从源头杜绝重复请求的发生。
- 后置处理：出现了重复请求之后能够自动取最后的请求，不发出之前的请求。
- 先找出重复请求的根源，比如一些按钮，用户短时间多次点击导致的多次请求，这时可以利用按钮的`disabled`属性关闭按钮的点击功能，又或者添加一些 loading 框，防止用户多次点击，导致重复请求。

#### 服务端渲染-SSR

`hydration` 注水：服务端渲染场景下，首次渲染返回静态字符串，并没有交互能力。这时需要对代码进行注水，使之功能完整。

### 2023.04.26

#### 1、什么是 mvvm、mvc 模型？

- **MVC**：是应用最广泛的软件架构之一，一般`MVC`分为:`Model(模型)`,`View(视图)`，`Controller(控制器)`。 这主要是基于分层的目的,让彼此的职责分开.`View`一般用过`Controller`来和`Model`进行联系。`Controller`是`Model`和`View`的协调者，`View`和`Model`不直接联系。基本都是单向联系。
- **MVVM**：`MVVM`是把`MVC`中的`Controller`改变成了`ViewModel`。`View`的变化会自动更新到`ViewModel`，`ViewModel`的变化也会自动同步到`View上`显示，通过数据来显示视图层。

#### 2、vue 双向数据绑定的原理

- **Vue2**:vue2 使用的是 ES5 的`Object.defineProperty`，当初始化的时候，需要递归的来对数据进行劫持操作，从而给每个属性绑定`getter`和`setter`，所以初始化的时候性能消耗会比较大。后期当我们读取值的时候，触发 getter 并收集依赖，当设置值的时候，触发相应依赖，进而更新视图。
- **Vue3**：vue3 使用的是 ES6 之后的`Proxy`代理对象，因为 Proxy 是对整一个对象进行代理，所以初始化的时候当遇到比较深层次的对象结构不需要递归给每个属性来绑定`getter`和`setter`，只需要给每一层的对象结构进行代理即可。所以性能方面比 Object.defineProperty 要好，还有 proxy 天生能劫持到数组的变化等优点。当我们访问 proxy 代理后的对象，就会触发 proxy 的 handle 中的 get 访问器，从而进行属性和依赖收集，当更改 proxy 代理后的对象，从根据当前的 effect 去 weakMap 映射表中找到所有相应的 effect 进行触发，并更新视图。

#### 3、介绍一些常用的 ES6 语法和特性

- proxy
- 箭头函数（解决有些场景的 this 指向问题）
- 解构赋值
- 可选链操作符（解决当值不存在的时候，减少条件判断的代码）
- Promise.all、Promise.race
- Map、Set、weakMap、weakSet 等数据结构

#### 4、常用的居中布局介绍

- flex
- Position （子绝父相）
- margin: 0 auto line-height:自身容器高度 （水平垂直居中）
- Text-align:center （文本水平居中）

#### 5、flex 布局介绍

- flex-direction: 定义主轴方向
- Justify-content：定义主轴的方向的水平调整元素之间的空间
- Align-items：定义主轴方向的垂直方向的元素之间的空间

#### 6、http 协议与 https 协议的区别？

**http**是超文本传输**协议**，信息是明文传输，**https** 则是具有安全性的**ssl**加密传输**协议 http**和**https**使用的是完全不同的连接方式用的端口也不一样,前者是 80,后者是 443。 **http**的连接很简单,是无状态的**HTTPS 协议**是由**SSL**+**HTTP 协议**构建的可进行加密传输、身份认证的网络**协议**。

#### 7、什么是深拷贝和浅拷贝？

深拷贝和浅拷贝区别是，**在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存**，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。深拷贝通常会使用到递归来实现，也可以使用 ES6 的 proxy 来实现，按需拷贝，读取到数据的哪一层就拷贝到哪一层，相对递归而言，该方案更灵活以及更节约性能。

#### 8、vue 组件间传值的方式？

- 父传子 props
- 子传父 emit （原理：通过父传递一个回调函数给子，子通过这个回调去更改父的状态）
- vuex/pina （公共状态管理）
- ref （不推荐）
- eventBus （不推荐，原理借鉴了 node 中的一个模块）
- localStorage

#### 9、vue 如何实现组件刷新，组件 key 属性的作用？

- 组件刷新：可通过`v-if`手动销毁创建组件，组件的状态会重置。
- 组件 key 属性的作用：用于 diff 算法对比的时候，最大程度的区分节点是否有变化，是否需要更新，减少 dom 的对比时间。

#### 10、promise 的作用？

promise 主要是解决了异步常见的回调方案里的层层回调函数形成的回调地狱问题，以及更加优雅的解决异步问题。

#### 11、前端的跨域策略，csrf，xss 攻击介绍

- 跨域：跨域，是浏览器出于安全考虑提出同源策略。是仅仅存在于浏览器和服务器之间，协议、端口号、域名有一个不同都违反了浏览器的同源策略。
- 解决方法：

  - jsonp：只支持 get 请求，不支持 post 请求
  - 反向代理：配置一下即可解决跨域问题，底层是帮我们开启了一个微型服务器，通过这个微型服务器去访问目标服务器取数据，去到数据再返回给浏览器，因为服务器和服务器之间是不存在跨域问题的。
  - ifram 标签+domain

- XSS：

  1、XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。

  2、XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

  3、可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。

  4、可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。

  5、可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。

  6、还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。

- CRRF：

  1、攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生；

  2、攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据；

  3、整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”；

  4、跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。

#### 12、get 和 post 的区别？

- get：`GET`方法请求一个指定资源的表示形式，使用 GET 的请求应该只被用于获取数据。
- post：`POST`方法用于将实体提交到指定的资源，通常导致在服务器上的状态变化或**副作用**。

区别：

- `GET`在浏览器回退时是无害的，而`POST`会再次提交请求。

- `GET`产生的 URL 地址可以被 Bookmark，而`POST`不可以。
- `GET`请求会被浏览器主动 cache（缓存），而`POST`不会，除非手动设置。
- `GET`请求只能进行 url 编码，而`POST`支持多种编码方式。
- `GET`请求参数会被完整保留在浏览器历史记录里，而`POST`中的参数不会被保留。
- `GET`请求在 URL 中传送的参数是有长度限制的，而`POST`没有。
- 对参数的数据类型，`GET`只接受 ASCII 字符，而`POST`没有限制。
- `GET`比`POST`更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。
- `GET`参数通过 URL 传递，`POST`放在 Request body 中

#### 13、var、let、const 声明的变量区别？

- `var`和`let`是用于声明变量，后期值可被更改，而`const`则是用于声明常量，后期如果是简单类型不能更改其值，如果是引用类型，则不能更改其引用地址。
- `var`会有变量提升这一特点，并且声明的变量会挂在 window 身上。
- `let`和`const`具有块级作用域特点，而`var`则没有。

#### 14、箭头函数的作用？

- **作用**：用于解决 this 指向问题，场景：比如在 vue2 中，我们利用 axios 来发送请求，因为 axios 是基于 promise 来实现的，请求成功回返回一个 promise，在 then 函数里，如果我们使用普通函数，那么里面 this 则不是指向 vue 实例，而是指向 axios 内部的 this，这时候我们就可以直接使用箭头函数，让里面的 this 指向外面一层，这样我们就不用在外层保存 this 再使用了。

- 箭头函数没有自己的 this，this 指向上一级。
- 箭头函数的参数如果只有一个可以去掉小括号，如果 return 后面只有一句代码的话可以省略大括号。
- 箭头函数没有自己的`arguments`数组，而是继承自父层的`argument`。
- 箭头函数没有自己的`prototype`。

#### 15、有没有了解过 typescript？

TypeScript 是 JS 的超集，JS 有的 TypeScript 都有，是 Type 和 JavaScipt 的结合，在 JS 的基础上为 JS 添加了类型系统。

1、从编程语言的动静来区分，TypeScript 属于静态类型的编程语言，JS 属于动态类型的编程语言。静态类型是编译期做类型检查，动态类型是执行期做类型检查。代码编译和代码执行的顺序本身是 1 编译 2 执行

2、从使用层面上，现在的 UI 组件库以及插件库随处可见，而内部使用 ts 实现的库，当我们用户使用层面上会得到很多类型提示，进而有时候甚至不需要文档也可以在别人的代码上进行开发。

#### 16、js 类型隐式转换介绍

- `==`和`===`两个等会隐式进行类型转换，比如`1 == '1'`则是返回 true 的，而`1 === '1'`则是返回 false。
- 比如一个 number 类型，`1 + ''`则会转换为了 string 类型的`'1'`。

#### 17、CSS 选择器及其优先级？

- 选择器：

  - `div > p` 子代选择器
  - `div p` 后代选择器
  - `div ~ p` 兄弟选择器
  - `#room` id 选择器

  - `.room` 类选择器

  - `h1、p` 标签选择器
  - `*` 通配符选择器

- 优先级：`!important` > `行内style` > `id选择器` > `类选择器` > `标签选择器` > `通配符选择器`

#### 18、如何实现图片截图？

可以利用现成的一些 npm 包实现。

- dom-to-image：dom-to-image 库主要使用的是 SVG 实现方式，简单来说就是先把 DOM 转换为 SVG 然后再把 SVG 转换为图片。
- html2canvas。

#### 19、性能优化，渲染优化介绍

- 网络层面：
  - 请求过程的优化
    - http 请求优化
      - 构建工具性能调优
      - Gzip 压缩原理
      - 图片优化
  - 减少网络请求
    - 本地存储
      - 浏览器缓存机制
      - 离线存储技术
- 渲染层面
  - 服务端渲染优化
  - 浏览器的渲染优化
    - CSS 性能优化方案
    - JS 性能优化方案
  - DOM 优化
    - 合理利用事件循环与异步更新
    - 减少回流与重绘
  - 首屏渲染提速：`SPA`应用的路由懒加载

#### 20、如何做屏幕适配，如何做移动端适配？

- 利用`vh/vw`单位适配。

- 利用媒体查询。

- 利用 rem 方案：

  rem（font size of the root element）是指相对于根元素的字体大小的单位，如果我们设置 html 的 font-size 为 16px，则如果需要设置元素字体大小为 16px，则写为 1rem。但是其还是必须得借助 @media 属性来为不同大小的设备设置不同的 font-size。

- 利用现在流行的原子化 css 库实现，如`taiwindcss`、`unocss`等。
